# Side Projects
The purpose of the side projects section is to work on possible features of the MOSAIC program for radio astronomy. These projects typically borrow heavily from the geometry engine but lack server communication. Typically these features will be implemented as functions to later be added the geometry engine as a whole or used by other interested parties in their own scripts. 

## Eclipse_Study
### Purpose
The purpose of this section of the program is to build a graph that will outline the angular distance between a satellite and the sun. The code EclipseStudy.py as standalone will generate a graph with angular distance from the sun and a satellite over the course of a specified day and month. To pick a different satellite put 1 TLE of the databaseGeneratorV1.py format into the text file associated with this repo. To pick a different day one has 2 options. The first is to change the value of the month and day variables at the beginning of ElipseStudy.py, if one chooses this option remember to find the generateDistance() function call and verify it is taking in the day and month values in that order. The second is find the generateDistance() function and change the day and month at the function call. 

## Using this Program/Function
To make this study more useful to the MOSAIC team as a whole the working part of this study has been made into a function which can easily be copied and pasted into the geometry engine or any other interested parties program. The name of this function is generateDistance(). The inputs of this function are day, month and satelliteID in that order. day and month are integers, satelliteID is a string with the NORAD ID of the satellite in question. To make sure this works copy lines 11-47 as written. The reason for this is that satelliteParser() depends on a value generated by a function call of satelliteParser() as does generateDistance(). The code will not work if the text file that satelliteParser() expects to read from isn't in the same folder as script calling the function. In EclipseStudy.py the text file is sltrack_iridium_perm_small.txt. The function returns a 1 by 1440 array with the angular distances of the satellite in question over the course of a day starting at 12am and ending at 11:59pm with each point represening a minute from the last position. This function does _not_ graph the output but if one wishes to graph the output that is done at the end of the ElcipseStudy.py program. 

| Input Name | Format | Description |
| day | number (int works best) | Day of interest |
| month | number (int works best) | Month of interest |
| Satellite ID | string | NORAD ID of the satellite of interest |

### Library Dependencies
If one wishes just to copy the function generateDistance() one needs the python libraries outlined below. One is able to copy these dependcies as written in this readme for ease of use. 
```
  from skyfield.api import load, wgs84, EarthSatellite, N, W,utc
  from skyfield.iokit import parse_tle_file
  from datetime import datetime as dt
  import numpy as np
  from matplotlib import pyplot as plt
```
### Function Dependencies
If one wishes just to copy the function generateDistance() one needs the functions from other parts of the MOSAIC organization outlined below. These functions also appear in the EclipseStudy.py program. Please see the section on using this program/function for more details on how to copy these functions into your code. 

  - satelliteParser()  -  note: this means that the code works with TLEs generated by the databaseGeneratorV1.py script
  - satelliteFinderID() 
  - positionAtTime() - note: this function was built for the operation of this program and is based off of latandlongfunction() in the geometry engine
```
def satelliteParser():
    #files and opens the file
    with open('sltrack_iridium_perm_small.txt', 'r') as file:
        #reads all lines into a list
        lines = file.readlines()  
        satelliteList = []


        #skips the first line which is the data
        #the range function allows to increment by 3 lines 
        #and start at line 1 instead of 0 and 
        #go to the end of the file
        for i in range(1, len(lines)):
            singleSatellite = []
            #takes each of the lines and gives them a 
            #corresponding variable
            temp = lines[i].split(",")
            name = temp[0].strip()
            tle1 = temp[1].strip()
            tle2 = temp[2].strip()
            NORADid = tle1[2:7]
            #loads the timescale using the 
            #official Earth Rotation data
            singleSatellite.append(name)
            singleSatellite.append(NORADid)
            singleSatellite.append(tle1)
            singleSatellite.append(tle2)

            satelliteList.append(singleSatellite)

    return satelliteList

# this code is vital to the proper functioning of the function always run this between
# satelliteParser() and satelliteFinderID 
templist = satelliteParser()
temp = templist[0]
SatelliteID = temp[1]



def satelliteFinderID(ID):
    for element in templist:
        if(element[1] == ID):
            return element
        

def positionAtTime(number,time,position):
    tempsatellite = satelliteFinderID(number)
    #Gets the satellite data loaded from a tle
    satellite = EarthSatellite(tempsatellite[2], tempsatellite[3], tempsatellite[0])

    difference = satellite - position
    #Gets the satellite's position
    satFromDiff = difference.at(time)

    alt, az, distance = satFromDiff.altaz()
    # print('Altitude:', alt.degrees)
    # print('Azimuth:', az.degrees)
    # print('Distance: {:.1f} km'.format(distance.km))
    return [alt.radians, az.radians]
```
### Function as written
For ease of use I have copied the generateDistance() function below for quick analysis by interested parties.

```
def generateDistance(day, month, SatelliteID):
    testtime = dt.fromisoformat('2011-11-04 00:05:23.283')
    testtime= testtime.replace(tzinfo=utc)      # to fix an existing datetime   
    out = [0]*1440
    for x in range(0,24):
        for y in range(0,60):
            realTime = testtime.replace(year = 2024, day = day, month = month, minute= y, hour = x, second= 0, microsecond=0)

            t = ts.from_datetime(realTime)

            # gets the distance vector for a satellite
            postemp = positionAtTime(SatelliteID,t,blacksburg)
            pos1 = [np.sin(np.pi/2-postemp[0])*np.cos(postemp[1]),np.sin(np.pi/2-postemp[0])*np.sin(postemp[1]),np.cos(np.pi/2-postemp[0])]        

            goeblacksburg = earth+ wgs84.latlon(37.2296 * N, 80.4139 * W)
            astrometric = goeblacksburg.at(t).observe(sun)
            alt, az, d = astrometric.apparent().altaz()
            pos2 = [np.sin(np.pi/2-alt.radians)*np.cos(az.radians),np.sin(np.pi/2-alt.radians)*np.sin(az.radians),np.cos(np.pi/2-alt.radians)]
    

            deltaA = (postemp[1]-az.radians)*np.cos(postemp[0])
            deltaB = postemp[1]-alt.radians
            out[x*60+y] = (180/np.pi)*(np.arccos(np.sin(alt.radians)*np.sin(postemp[1])+np.cos(alt.radians)*np.cos(postemp[1])*np.cos(az.radians-postemp[0])))
    return out
```
## Doppler Effect Calculator
### Purpose
The purpose of this section of the program is to build a function able to calculate the doppler shifted frequency of a satellite given that satelliltes frequency. This is done by using a new function designed specifically for the purpose of getting the velocity of satellites relative to an oberserver. This function appears in function dependencies of this function. 

### Using this as a function
To use this as a function one needs to call the function with satellite number input as a string, time of day in the skyfield time format, position in the skyfield format and frequency as a number (double works best). Before calling the function review the function dependencies as well as make sure there is a text file with the TLE of the format output by the MOSAIC database generator. 


  
