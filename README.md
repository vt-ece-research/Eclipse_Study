# Eclipse_Study
## Purpose
The purpose of this section of the program is to build a graph that will outline the angular distance between a satellite and the sun. The code EclipseStudy.py as standalone will generate a graph with angular distance from the sun and a satellite over the course of a specified day and month. To pick a different satellite put 1 TLE of the databaseGeneratorV1.py format into the text file associated with this repo. To pick a different day one has 2 options. The first is to change the value of the month and day variables at the beginning of ElipseStudy.py, if one chooses this option remember to find the generateDistance() function call and verify it is taking in the day and month values in that order. The second is find the generateDistance() function and change the day and month at the function call. 

## Using this Program/Function
To make this study more useful to the MOSAIC team as a whole the working part of this study has been made into a function which can easily be copied and pasted into the geometry engine or any other interested parties program. The name of this function is generateDistance(). The inputs of this function are day, month and satelliteID in that order. day and month are integers, satelliteID is a string with the NORAD ID of the satellite in question. To make sure this works copy lines 11-47 as written. The reason for this is that satelliteParser() depends on a value generated by a function call of satelliteParser() as does generateDistance(). The code will not work if the text file that satelliteParser() expects to read from isn't in the same folder as script calling the function. In EclipseStudy.py the text file is sltrack_iridium_perm_small.txt. The function returns a 1 by 1440 array with the angular distances of the satellite in question over the course of a day starting at 12am and ending at 11:59pm with each point represening a minute from the last position. This function does _not_ graph the output but if one wishes to graph the output that is done at the end of the ElcipseStudy.py program. 

## Library Dependencies
If one wishes just to copy the function generateDistance() one needs the python libraries outlined below. One is able to copy these dependcies as written in this readme for ease of use. 

  from skyfield.api import load, wgs84, EarthSatellite, N, W,utc
  from skyfield.iokit import parse_tle_file
  from datetime import datetime as dt
  import numpy as np
  from matplotlib import pyplot as plt

## Function Dependencies
If one wishes just to copy the function generateDistance() one needs the functions from other parts of the MOSAIC organization outlined below. These functions also appear in the EclipseStudy.py program. Please see the section on using this program/function for more details on how to copy these functions into your code. 

  satelliteParser()  -  note: this means that the code works with TLEs generated by the databaseGeneratorV1.py script
  satelliteFinderID() 
  positionAtTime() - note: this function was built for the operation of this program and is based off of latandlongfunction() in the geometry engine

## Function as written
For ease of use I have copied the generateDistance() function below for quick analysis by interested parties.

def generateDistance(day, month, SatelliteID):
    testtime = dt.fromisoformat('2011-11-04 00:05:23.283')
    testtime= testtime.replace(tzinfo=utc)      # to fix an existing datetime   
    out = [0]*1440
    for x in range(0,24):
    # (part 2) edites the generic time with int values
        for y in range(0,60):
            realTime = testtime.replace(year = 2024, day = day, month = month, minute= y, hour = x, second= 0, microsecond=0)

            t = ts.from_datetime(realTime)

            # gets the distance vector for a satellite
            postemp = positionAtTime(SatelliteID,t,blacksburg)
            pos1 = [np.sin(np.pi/2-postemp[0])*np.cos(postemp[1]),np.sin(np.pi/2-postemp[0])*np.sin(postemp[1]),np.cos(np.pi/2-postemp[0])]        

            goeblacksburg = earth+ wgs84.latlon(37.2296 * N, 80.4139 * W)
            astrometric = goeblacksburg.at(t).observe(sun)
            alt, az, d = astrometric.apparent().altaz()
            pos2 = [np.sin(np.pi/2-alt.radians)*np.cos(az.radians),np.sin(np.pi/2-alt.radians)*np.sin(az.radians),np.cos(np.pi/2-alt.radians)]
    

            deltaA = (postemp[1]-az.radians)*np.cos(postemp[0])
            deltaB = postemp[1]-alt.radians
            out[x*60+y] = (180/np.pi)*(np.arccos(np.sin(alt.radians)*np.sin(postemp[1])+np.cos(alt.radians)*np.cos(postemp[1])*np.cos(az.radians-postemp[0])))
    return out


  
